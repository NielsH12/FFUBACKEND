/*
 * generated by Xtext 2.12.0
 */
package dk.sdu.ffu.pint.validation

import dk.sdu.ffu.pint.pint.EntityPolicy
import dk.sdu.ffu.pint.pint.Everyone
import dk.sdu.ffu.pint.pint.PintPackage
import dk.sdu.ffu.pint.pint.RolePolicy
import org.eclipse.xtext.validation.Check
import dk.sdu.ffu.pint.pint.Intermediary
import org.eclipse.xtext.EcoreUtil2
import dk.sdu.ffu.pint.pint.Endpoint
import dk.sdu.ffu.pint.pint.RoleRef
import dk.sdu.ffu.pint.pint.StringComparison
import dk.sdu.ffu.pint.pint.rStringComparison
import dk.sdu.ffu.pint.pint.EntityProperty
import dk.sdu.ffu.pint.pint.StringPrim
import dk.sdu.ffu.pint.pint.QueryParamRef
import dk.sdu.ffu.pint.pint.BodyRef
import dk.sdu.ffu.pint.pint.EntityPropertyRef
import dk.sdu.ffu.pint.pint.Property
import dk.sdu.ffu.pint.pint.Type
import dk.sdu.ffu.pint.pint.EntityRef
import dk.sdu.ffu.pint.pint.Entity
import dk.sdu.ffu.pint.pint.TreeElement
import dk.sdu.ffu.pint.pint.BranchElement
import dk.sdu.ffu.pint.pint.LeafElement
import dk.sdu.ffu.pint.pint.StringValue
import dk.sdu.ffu.pint.pint.tString
import dk.sdu.ffu.pint.pint.tInt
import dk.sdu.ffu.pint.pint.tFloat
import dk.sdu.ffu.pint.pint.tBoolean
import dk.sdu.ffu.pint.pint.tDate
import dk.sdu.ffu.pint.pint.Comparison
import dk.sdu.ffu.pint.pint.DateComparison
import dk.sdu.ffu.pint.pint.DateExp
import dk.sdu.ffu.pint.pint.today

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PintValidator extends AbstractPintValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					PintPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	def checkStringComparisonWithStrings(StringComparison stringComparison) {
		val left = stringComparison.left.findValueTypeRoot
		val right = stringComparison.right.findValueTypeRoot
		if (left != "string"){
			error("Value is not of type: string", 
				PintPackage.Literals.STRING_COMPARISON__LEFT)
		}
		
		if (right != "string"){
			error("Value is not of type: string", 
				PintPackage.Literals.STRING_COMPARISON__RIGHT)
		}
	}
	
	@Check
	def checkStringComparisonWithStrings(rStringComparison stringComparison) {
		val left = stringComparison.left.findValueTypeRoot
		val right = stringComparison.right.findValueTypeRoot
		if (left != "string"){
			error("Value is not of type: string", 
				PintPackage.Literals.RSTRING_COMPARISON__LEFT)
		}
		
		if (right != "string"){
			error("Value is not of type: string", 
				PintPackage.Literals.RSTRING_COMPARISON__RIGHT)
		}
	}
	
	@Check
	def checkDateComparisonWithDates(DateComparison dateComparison) {
		val left = dateComparison.left.findValueTypeRoot
		val right = dateComparison.right.findValueTypeRoot
		if (left != "date"){
			error("Value is not of type: date", 
				PintPackage.Literals.DATE_COMPARISON__LEFT)
		}
		
		if (right != "date"){
			error("Value is not of type: date", 
				PintPackage.Literals.DATE_COMPARISON__RIGHT)
		}
	}

	@Check
	def checkOnlyOneRolePolicyPrRole(RolePolicy policy) {
		
		if(policy.role.roleRefs instanceof RoleRef){
		
			val rolePolicies = EcoreUtil2.getContainerOfType(policy, Intermediary).elements
				.filter(RolePolicy)
				.filter[role.roleRefs instanceof RoleRef ]
				.filter[role.roleRefs.ref.name == policy.role.roleRefs.ref.name]
	
			var thereShouldOnlyBeOne = 1;
			
			for(p: rolePolicies){
	
				var endpointName = EcoreUtil2.getContainerOfType(policy.restResource, Endpoint).name
				var iteratorEndpointName = EcoreUtil2.getContainerOfType(p.restResource, Endpoint).name
				
				if(endpointName == iteratorEndpointName && p.role.roleRefs.ref.name == policy.role.roleRefs.ref.name && p.restResource.name == policy.restResource.name){
					if(thereShouldOnlyBeOne > 1){
						error(policy.role.roleRefs.ref.name + ' already have a policy for the resource: ' + policy.restResource.name, 
							PintPackage.Literals.ROLE_POLICY__REST_RESOURCE)
					}
					thereShouldOnlyBeOne += 1
				}
			}
		
		} else {
			
			val rolePolicies = EcoreUtil2.getContainerOfType(policy, Intermediary).elements
				.filter(RolePolicy)
				.filter[!(role.roleRefs instanceof RoleRef)]
	
			var thereShouldOnlyBeOne = 1;
			
			for(p: rolePolicies){
	
				var endpointName = EcoreUtil2.getContainerOfType(policy.restResource, Endpoint).name
				var iteratorEndpointName = EcoreUtil2.getContainerOfType(p.restResource, Endpoint).name
				
				if(endpointName == iteratorEndpointName && p.restResource.name == policy.restResource.name){
					if(thereShouldOnlyBeOne > 1){
						error("Duplicate public resource", 
							PintPackage.Literals.ROLE_POLICY__REST_RESOURCE)
					}
					thereShouldOnlyBeOne += 1
				}
			}
		}
		
	}


	@Check
    def checkEntityPolicyIsNotUsedOnPost(EntityPolicy entityPolicy) {
        if(entityPolicy.restResource.httpVerb == "POST"){
            warning('EntityPolicies are not evaluated on POST methods', PintPackage.Literals.ENTITY_POLICY__REST_RESOURCE)
        }
    }
    
    @Check
    def checkEveryonePolicyHasNoCondition(RolePolicy rolePolicy) {
        if(rolePolicy.role instanceof Everyone){
        	if (rolePolicy.require !== null){
        		warning('Conditions are not evaluated on public resources', PintPackage.Literals.ROLE_POLICY__REQUIRE)	
        	}
        }
    }
    
	
	def static dispatch findValueTypeRoot(StringValue x){
		return x.findValueType
	}
	
	def static dispatch findValueTypeRoot(DateExp x){
		return x.findValueType
	}
	
		def static dispatch findValueType(today x){
			return "date"
		}

	def static dispatch findValueType(StringPrim x){
		return "string"
	}
	def static dispatch findValueType(EntityProperty x){
		return x.entityPropertyRef.findValueType
	}
	
		def static dispatch findValueType(EntityPropertyRef x){
			if(x.ref !== null){
				return x.ref.findValueType
			} else {
				return x.propertyRef.findValueType
			}
		}
		
			def static dispatch findValueType(Property x){
				return x.type.findValueType
			}
		
				def static dispatch findValueType(Type x){			
					switch(x){
						case x instanceof tString: { println("string") return "string" }
						case x instanceof tInt: return "int"
						case x instanceof tFloat: return "float"
						case x instanceof tBoolean: return "boolean"
						case x instanceof tDate: return "date"
						default: { println("ERROR") return "error" }
					}
				}
	
	def static dispatch findValueType(QueryParamRef x){
		return x.ref.type
	}
	
	def static dispatch findValueType(BodyRef x){
		return x.jsonRef.findValueType
	}
	
		def static dispatch findValueType(BranchElement x){
			return x.child.findValueType
		} 
		
		def static dispatch findValueType(LeafElement x){
			return x.kvPairRef.type
		} 	
}
